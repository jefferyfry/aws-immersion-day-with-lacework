[
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/1_event_engine_setup.html",
	"title": "AWS Hosted Event Setup",
	"tags": [],
	"description": "",
	"content": "Welcome to the Event Engine Setup section! This means that you are attending an AWS Hosted Workshop!! . Event Engine is a tool created at AWS that provisions AWS accounts for workshop events like this! These accounts will automatically terminate 24 hours after the workshop begins participants don\u0026rsquo;t have to worry about leaving anything on. Each workshop participant will receive their own Event Engine AWS account.\nWhat We Will Do Get a temporary AWS account using the AWS Event Engine. Access your AWS Console Get your Lacework access email Access the Lacework instance The next page will show you how to gain access to your Event Engine dashboard!\n"
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/",
	"title": "AWS Immersion Day with Lacework",
	"tags": [],
	"description": "",
	"content": "\nAWS Immersion Day with Lacework Welcome The Lacework Cloud Security Platform delivers comprehensive and continuous end-to-end AWS security and configuration support for both workloads and accounts running in cloud environments. As more organizations move their critical workloads to the cloud, there is an increasing need for a single, unified solution like the Lacework Cloud Security Platform that can identify, analyze, and report on misconfigurations, vulnerabilities, and behavioral anomalies in user and account behavior.\nThis session includes several modules that explore different aspects of your software delivery and cloud operations:\nDeploying seamless multi-account management for cloud security on AWS Securing your software delivery process with shift-left DevSecOps best practices with AWS developer tools Implementing a security operation workflow for AWS cloud environments While exploring these topics we will show you how Lacework integrates and protects you and your AWS services:\nAWS CodePipeline AWS CodeBuild Amazon Elastic Container Registry (ECR) Amazon Elastic Container Service (ECS) Amazon Elastic Kubernetes Service (EKS) AWS Security Hub Amazon Control Tower AWS CloudFormation The examples and sample code provided in this session are intended to be consumed as instructional content. These will help you understand how various services can be architected to build a solution while demonstrating best practices along the way. These examples are not intended for use in production environments.\nThanks for joining this session and let\u0026rsquo;s get started!\n"
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/2_lacework_aws_integration.html",
	"title": "How Lacework Integrates with AWS",
	"tags": [],
	"description": "",
	"content": "Every activity within a cloud environment increases the potential for threats, and AWS users must have a solution that not only identifies changes, but understands the security context of them. To address the agile nature of the cloud, Lacework provides comprehensive, continuous end-to-end security and configuration support for workloads and accounts running in AWS cloud environments. In this section, we will explore how the Lacework platform integrates with AWS configuration, CloudTrail, agents and CI/CD in order to secure your cloud environments. "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/3_lacework_console_overview.html",
	"title": "Lacework Console Overview",
	"tags": [],
	"description": "",
	"content": "The Lacework console is the centralized UI for Lacework Cloud Security. From the console, you can investigate security events, check your cloud compliance, validate your software vulnerabilities and explore your cloud resources. "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/4_cspm_plus.html",
	"title": "Advanced Cloud Security Posture Management (CSPM+)",
	"tags": [],
	"description": "",
	"content": "In this section, we will explore Lacework\u0026rsquo;s advanced cloud security posture management (CSPM+) through an AWS S3 Ransomware attack. In this scenario, we will see how Lacework can detect S3 misconfigurations and alert you to the S3 vulnerability. In the case when no action is taken, you will see how Lacework\u0026rsquo;s Polygraph technology detects the anomalous behavior and further enable you to quickly investigate the activity.\n"
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/5_devsecops_plus_eks.html",
	"title": "DevSecOps+: Secured Software Delivery Pipeline with EKS",
	"tags": [],
	"description": "",
	"content": "In this section, we will set up a CI/CD pipeline with AWS CodePipeline and CodeBuild. Our CodePipeline pipeline will take our code from S3 and scan the code and infrastructure-as-code (IaC) for vulnerabilities. Then it will build a docker image and scan for OS and package vulnerabilities. Then it will push it to Amazon Elastic Container Registry (ECR). Then we will deploy it to a staging and production environments1x that runs on an Amazon Elastic Kubernetes Service (EKS) cluster. At each stage, Lacework protects your application and cloud environment.\nWhat We Will Do Review the CI/CD architecture. Review the CloudFormation template that was used to set up the lab. Inspect the configuration of CodePipeline, CodeBuild, ECR, EKS and Lacework components. Execute the pipeline manually. Understand how Lacework protects your DevOps pipeline and multiple stages. Pipeline "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/1_event_engine_setup/11_aws_event_account.html",
	"title": "Access Your Temporary AWS Account",
	"tags": [],
	"description": "",
	"content": " Only complete this section if you are running the workshop through an AWS hosted event.\nFor an AWS hosted event, you are provided with an AWS account through the AWS Event Engine service using a 12-digit hash by event staff. This is your unique access code.\n1 . Go to https://dashboard.eventengine.run/.\nEnter the provided hash code in the text box.\nClick on the Accept Terms \u0026amp; Login button.\nSelect AWS Console.\nThen select Open AWS Console.\nThis workshop supports the region us-west-2 US West (Oregon). Please select US West (Oregon) in the top right corner. You can leave the AWS console open.\nThis AWS account will expire at the end of the workshop and any resources will automatically be de-provisioned. You will not be able to access this account after today.\n"
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/1_event_engine_setup/12_lacework_account.html",
	"title": "Access Lacework",
	"tags": [],
	"description": "",
	"content": "There were two ways to access the Lacework console: (1) via the invitation email or (2) via login.\nInvitation Email If you have not used your invitation email, look for it in your inbox. Click on the Join Now link in the email. Accept the terms. Welcome to Lacework! Login If you have already used the invitation email, and you are ready to login, go to the Lacework console URL. Enter your email into the login form. Check your inbox for the single-use login email. Click on the GO TO MY CONSOLE link. Welcome to Lacework! "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/2_lacework_aws_integration/21_cloudformation_setup.html",
	"title": "CloudTrail and AWS Configuration Integration via Console and CloudFormation",
	"tags": [],
	"description": "",
	"content": "The Lacework platform platform at a minimum requires integration with the AWS configuration for an account in order to check security posture of resources. CloudTrail is recommended in order to monitor user, API and resource activity for suspicious behavior. AI/ML are applied to this activity in order to detect anomalous behavior.\nNavigate to Settings \u0026gt; Integrations \u0026gt; Cloud Accounts in your console. Click + Add New. Select AWS. Select CloudTrail+Config or Config and click Next. Select CloudFormation. Click on the Run CloudFormation Template to be taken to the CloudFormation console. View the CloudFormation stack parameters, but don\u0026rsquo;t execute in this session. "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/2_lacework_aws_integration/22_aws_control_tower.html",
	"title": "Multi-Account Onboarding with AWS Control Tower",
	"tags": [],
	"description": "",
	"content": "With Lacework and AWS Control Tower, enrolling a new AWS account now means security best practices and monitoring are automatically applied consistently across your organization. Account administrators can automatically add Lacework\u0026rsquo;s security auditing and monitoring to AWS accounts seamlessly. All the required Lacework and AWS account configurations that allow access to AWS configuration and CloudTrail logs are managed for you by Lacework’s AWS Control Tower integration.\nThe Lacework AWS Control Tower integration audits and monitors AWS accounts in your AWS Control Tower Landing Zone. Your Landing Zone is your multi-account environment for which you can apply your governance, auditing and monitoring. On initial setup, the Lacework AWS Control Tower integration creates a new cross-account role in the Log Archive account and a new SQS queue is set up in the Audit account. The SQS queue allows Lacework to receive notifications of new audit logs in S3 from the centralized CloudTrail that collects activity from all accounts. Lacework processes these logs for behavior analysis for all AWS accounts.\nFor new AWS accounts in your organization, AWS Control Tower Account Factory enables easy onboarding of new and existing AWS accounts which triggers the Lacework integration through a new account lifecycle event. A Lambda function launches a stack instance that creates a new cross-account role and allows Lacework to monitor the account via AWS APIs. The combination of CloudTrail log analysis and AWS API access allows Lacework to check your cloud activity and AWS configuration to detect security misconfigurations and anomalous behavior.\nThe Lacework AWS Control Tower integration uses CloudFormation to install StackSets, IAM roles, Lambda functions and SQS queues that support the integration. Follow the next steps to install the integration through your AWS CloudFormation console.\nLogin in to AWS master account with Administrator permissions. Select the AWS region where your AWS Control Tower is deployed. Click on the following Launch Stack button to go to your CloudFormation console and launch the AWS Control Integration template. For most deployments, you only need the Basic Configuration parameters. Use the Advanced Configuration for customization. Specify the following Basic Configuration parameters: Enter a Stack name for the stack. Enter Your Lacework URL. Enter your Lacework Sub-Account Name if you are using Lacework Organizations. Enter your Lacework Access Key ID and Secret Key that you copied from your previous API Keys file. For Capability Type, the recommendation is to use CloudTrail+Config for the best capabilities. Choose whether you want to Monitor Existing Accounts. This will set up monitoring of ACTIVE existing AWS accounts. Enter the name of your Existing AWS Control Tower CloudTrail Name. If your CloudTrail S3 logs are encrypted, specify the KMS Key Identifier ARN. Update the Control Tower Log Account Name and Audit Account Name if necessary. Click Next through to your stack Review. Accept the AWS CloudFormation terms and click Create stack. Monitor the progress of the CloudFormation deployment. It takes several minutes for the stack to create the resources that enable the Lacework AWS Control Tower Integration. When successfully completed, the stack shows CREATE_COMPLETE. "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/2_lacework_aws_integration/23_agent_integration.html",
	"title": "EC2, EKS, ECS, Fargate Agent Integration",
	"tags": [],
	"description": "",
	"content": "For hosts, container services and Kubernetes, optional agents can be installed to enable security monitoring at the edge of the cloud. Lacework agents are lightweight and send network and process telemetry for security analysis. Lacework agents are supported on most x86, ARM and container runtimes. The Lacework Agent also supports AWS Graviton processors and is AWS Graviton Ready. Deploying an agent requires an agent access token and using the installation method that is appropriate for your environment.\nIn the Lacework Console, navigate to Settings \u0026gt; Configuration \u0026gt; Agents. Click + Add New. In the Name field, enter a unique logical name for the agent token. You can use the agent access token name to logically separate your deployments, for example, by environment types (QA, Dev, etc.) or system types (CentOS, RHEL, etc.). In the Description field, you can optionally specify a description. Click Save. Click on the \u0026hellip; \u0026gt; Install link to see the deployment options. "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/2_lacework_aws_integration/24_kubernetes_integration.html",
	"title": "EKS (Kubernetes) Control Plane Integration",
	"tags": [],
	"description": "",
	"content": "All Kubernetes activities, whether manual activities with the kubectl tool, or automated, results in one or more API calls to the Kubernetes API server. Lacework can ingest these events to monitor activities, including kubectl exec, port-forwarding, deployment of new resources such as workloads, Kubernetes roles and role bindings, deletion of resources, authentication issues, forbidden API calls, and more. The Lacework Polygraph Data Platform surface the most important events such as the execution of rogue containers, the deployment of misconfigured workloads, the addition of dangerous roles, or manual login to containers.\nNavigate to Settings \u0026gt; Integrations \u0026gt; Cloud Accounts in your console. Click + Add New. Select AWS. Select EKS Audit Log and click Next. Select CloudFormation. Click on the Run CloudFormation Template to be taken to the CloudFormation console. View the CloudFormation stack parameters, but don\u0026rsquo;t execute in this session. "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/2_lacework_aws_integration/25_registry_integration.html",
	"title": "ECR Container Registry Integration",
	"tags": [],
	"description": "",
	"content": "If your development teams are doing microservices development and delivering container images, Lacework can be enabled to scan your images for software vulnerabilities. Lacework can scan OS and software packages and alert you to vulnerabilities. Lacework supports the most popular container registries including Amazon Elastic Container Registry (ECR).\nLacework also has a proxy scanner which allows Lacework to perform container vulnerability assessments for your on-premises Docker container image registries without exposing them to external connectivity. You can learn more about the Lacework Proxy Scanner here.\nNavigate to Settings \u0026gt; Integrations \u0026gt; Container Registries. Click + Add New. Select a registry type. Select the registry integration type and click Next. Complete any settings and click Save. "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/2_lacework_aws_integration/26_cicd_integration.html",
	"title": "CodePipeline, CodeBuild CI/CD Integration",
	"tags": [],
	"description": "",
	"content": "With Lacework, you can also discover software vulnerabilities during your software build process. This is done through use of the Lacework inline scanner. The Lacework inline scanner can be integrated with many CI/CD tools including AWS CodePipeline and CodeBuild. You can see AWS CodePipeline and CodeBuild examples in the DevSecOps modules. Similar to the container registry scanning, the inline scanner can detect software vulnerabilities in OS and software packages.The inline scanner is configured in the Container Registries settings menu:\nNavigate to Settings \u0026gt; Integrations \u0026gt; Container Registries. Click + Add New. Select Inline Scanner and click Next. Name the integration and click Next. Complete any optional settings. Check out CI/CD Policies and click Save. Click on the new inline scanner in the list. This displays a window that provides the inline scanner’s download URL and authorization token. Click the Authorization Token’s Copy to clipboard icon. This is the integration’s associated token. You need this to configure the inline scanner. Examples of how to integrate the inline scanner with the following CI/CD tools are available:\nJenkins TravisCI GitHub Actions Bitbucket Pipelines "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/3_lacework_console_overview/31_global_dashboard.html",
	"title": "Lacework Dashboard",
	"tags": [],
	"description": "",
	"content": "\nThe top pane of the Dashboard displays a visual summary of the following items:\nAll logs, network, user, and process events ingested by Lacework Entity behaviors and alerts identified by Lacework High and critical alerts generated by Lacework The alerts pane display a summary of your alert criticality, host related alerts and cloud related alerts.\nThe cloud compliance pane shows your compliance over time.\nThis pane shows a summary of incoming data and behaviors.\nThe Dashboard provides a quick view of your cloud security posture. It gives you a summary of your security data, alerts and compliance.\n"
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/3_lacework_console_overview/32_alerts.html",
	"title": "Alerts",
	"tags": [],
	"description": "",
	"content": "\nBy default, the Alerts page displays all alerts. You can use the following methods to refine the list of displayed alerts:\nUse filters to display a subset of specific alerts. Click the filter groups along the top of the page to display the list of filters associated with the selected filter group, then select the filters that you want to apply. Click Show more to display all the filter groups.\nUse the search function to display a subset of specific alerts. Click the search icon to see a list of field names that you can use to build your search.\nUse the time filter to display a subset of specific alerts based on when they occured.\n"
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/3_lacework_console_overview/33_compliance_cloud.html",
	"title": "Compliance Cloud",
	"tags": [],
	"description": "",
	"content": "Lacework’s AWS security platform automatically validates all configurations against the controls established as best practices for securing your cloud environment. Our interactive reports deliver insights into “passed or failed” controls with recommendations on how to fix out-of-compliance configuration components.\nThis dashboard provides a consolidated view of your compliance across all cloud providers that are integrated with Lacework.\nUse the Group by \u0026hellip; pulldown in the upper right to group your compliance by Assessment, Policy, Account or Service.\nGroup by Assessment This filter allows you to view compliance checks by the benchmark assessment.\nGroup by Policy This filter allows you to view compliance checks by the specific policies.\nGroup by Account This filter allows you to view compliance checks by the account.\nGroup by Service This filter allows you to view compliance checks by the associated cloud service.\n"
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/3_lacework_console_overview/34_container_vulnerabilities.html",
	"title": "Container and Host Vulnerabilities",
	"tags": [],
	"description": "",
	"content": "Lacework provides the ability to assess, identify, and report vulnerabilities found on hosts, containers, registries and pods within your environment. This means you can identify and take action on software vulnerabilities in your environment and manage that risk proactively.\nLacework continuously assesses vulnerability risks, identifies OS packages, and correlates them with publicly known vulnerabilities with risk ratings by severity and CVSS scores.\nIn this section, we will explore container vulnerabilities. Lacework several types of container/image scanning as well as providing runtime protection. Lacework provides similar capabilities for hosts such as EC2 instances. Lacework provides Public Registry Scanning, Private Registry Scanning, Continuous Integration (CI) Scanning and Local Scanning.\nSelect Vulnerabilities \u0026gt; Containers in the Lacework Console. By default, the page displays Fixable and Active vulnerabilities. Observe the Open Vulnerabilities panel. depicts open vulnerabilities. Hover your mouse over the Open Vulnerabilities chart to see the critical, high, medium, and low vulnerabilities. View the Vulnerabilties List panel. It shows the list of images with vulnerabilities. Click on an image in the list to view the image assessment details. View the summary and list of CVEs in the CVE tab. Click on the Details tab. This provides image details. This image is deployed and is an active container. Scroll down and click on the Active Containers link. This Container Dossier provides the details and activity. Scroll down to the List of Active Containers panel to see where the container is deployed. Lacework\u0026rsquo;s Container Security features enable you to shift your cloud security left into your software delivery process at multiple stages. You can prevent security vulnerabilities from being deployed.\nChallenge Find the vulnerable image running in an active container. What\u0026#39;s the image name and where is it running? The image is demo-app and it is running in an ECS cluster. "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/3_lacework_console_overview/35_resources.html",
	"title": "Resources",
	"tags": [],
	"description": "",
	"content": "The Lacework Console provides visibility into AWS resources that are integrated with Lacework. A resource can be any entity within the cloud deployment, such as an S3 bucket, security group, or EC2 instance. The Resource Inventory page allows you to view and monitor in-use AWS resources’ risk, compliance, and configuration changes and provides visibility for team members with limited or no access to the AWS Management Console. Because Lacework takes regular snapshots of your resources, you can track their changes (diffs) through the Lacework Console.\nGo to Resources \u0026gt; Cloud \u0026gt; AWS CloudTrail in the Lacework Console. Lacework analyzes the use and API activity from AWS CloudTrail logs. View the Timeline panel on the right to observe anomalous events detected from the CloudTrail activity. Scroll down to the Polygraph panel. Lacework\u0026rsquo;s Patented Polygraph feature graphs your user and API activity and enables you to see the sequence of behaviors. Additionally, anomalous behavior is flagged and highlighted as RED. Use the Search field to filter the Polygraph on services, resources API calls, accounts, users and responses. Use the DIFF button on the right to compare the current Polygraph snapshot to the previous (1 hour). This helps you understand the changes that have occurred. Go to Resources \u0026gt; AWS \u0026gt; Inventory. The Resource Inventory page allows you to view and monitor in-use AWS resources’ risk, compliance, and configuration changes. Click on a resource to view the resource configuration details. When a diff is present, it is always compared to the current configuration. If more than two configuration histories exist, click View more to display the Configuration History page. Lacework inventories all of your cloud resources and tracks their configuration changes. This can help you determine if recent configuration changes are the source of issues.\nChallenge Use the inventory to identify the EKS clusters in the environment. How many EKS clusters are active? Actual number may vary. "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/3_lacework_console_overview/36_policies.html",
	"title": "Policies",
	"tags": [],
	"description": "",
	"content": "Lacework policies provide a framework for validating configuration and behavior in your cloud environment. Lacework provides a set of predefined default policies that are visible from the Lacework Console. You can use the default policies to suppress the generation of unwanted alerts in your environment. Default policy IDs start with the LW_ prefix. You may want to create custom policies that check for unwanted behavior in your environment such as Telnet being used in your environment. You can also customize the triggers and severities for custom policies. Custom policy IDs start with the CUSTOM_ prefix.\nGo to Policies in the Lacework Console. The Policies page displays all policies. It provides a summary and list of all of your default and custom policies. You can use the following methods to refine the list of displayed policies: Use filters to display a subset of specific policies. Click filters along the top of the page to display only the desired policies. Or click the filter icon and select the filters you want to display. Use the search function at the top of the page to find specific text in the policy name or ID. When the page displays your desired policies after filtering, you can save the current view by clicking the Save view icon in the top right corner. This allows you to access the saved view later through the Open view icon.\nScroll through the list of policies. You can disable or enable each policy directly from the policies list. Mousing over a policy displays icons for any available actions such as clone or delete. You can also click a policy to clone it (create a custom policy) or edit a custom policy\u0026rsquo;s queries and parameters. Click a policy to display its details. The Summary tab lists details of the policy. Click on the Query detail to view the policy query that is used for validation. To create a custom policy, clone an existing policy first. Update the name, summary details and query. For custom policy queries, Lacework allows simple comparison expressions that are created in the console. Learn more about the types of expressions that you can use here.\nLacework default policies enable out-of-the-box security validation of your AWS environments. But not every organization is the same and custom policies are a great way to add validation specific to your organization\u0026rsquo;s requirements.\nChallenge How many pre-built Lacework policies are there? Check the Policy Types chart on the Policies page (750+). "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/3_lacework_console_overview/37_alert_channels_rules.html",
	"title": "Alert Channels and Rules",
	"tags": [],
	"description": "",
	"content": "Lacework combines alert channels and alert rules to provide a flexible method for routing alerts. For alert channels (outgoing integrations), you define information about where to send alerts, such as to Jira or Slack. For alert rules, you define information about which alert types to send, such as critical and high severity compliance alerts. This two-part method provides the flexibility to define multiple channels and multiple rules and then have each rule use the channels you specify.\nLacework provides alert channels for the following:\nAmazon CloudWatch Amazon S3 Data Export Cisco WebEx DataDog GCP Pub/Sub IBM QRadar Jira Cloud Jira Server Microsoft Teams New Relic PagerDuty ServiceNow Slack Splunk VictorOps Webhook Navigate to Settings \u0026gt; Notifications \u0026gt; Alert Channels. Click + Add New. Select a channel and click Next. Complete the fields to configure the channel. See each channel\u0026rsquo;s separate help for detailed field information. Click Save. The new channel appears in the table. Now the alert channel can be used by an alert rule. An alert rule allows you to choose which resource groups and event categories you want to receive alerts for. Navigate to Settings \u0026gt; Notifications \u0026gt; Alert Rules. Click + Add New. Select an alert channel for the rule to use. The list displays only enabled configured channels. Add additional channels if appropriate. Name the rule and optionally provide a description. Select the severities that you want the rule to apply to. Select the resource groups that you want the rule to apply to. Select the event categories that you want the rule to apply to. If you do not select any categories, the rule applies to all event categories. Click Save. The new rule appears in the table. Alert channel and rules provide a way to send Lacework security events to other tools. Lacework can integrate into your organization\u0026rsquo;s security operations workflow and tools.\n"
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/4_cspm_plus/41_anatomy_attack.html",
	"title": "Anatomy of the Attack",
	"tags": [],
	"description": "",
	"content": "\nIn this scenario, we simulate the typical ransomware actions where an attacker gains access to sensitive data.\nAn attacker gains access to a bastion host that is exposed to the internet. From the bastion host, the attacker scans for s3 buckets (using the preinstalled AWS CLI). The attacker discovers an S3 bucket with sensitive documents. The attacker uses encryption keys to encrypt the documents. "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/4_cspm_plus/42_compliance.html",
	"title": "Cloud Security Compliance",
	"tags": [],
	"description": "",
	"content": "Lacework’s AWS security platform automatically validates all configurations against the controls established as best practices for securing your cloud environment. The first step in preventing an attack is secure your cloud configuration. Lacework monitors your AWS environments and notifies you of security misconfigurations.\nGo to Compliance \u0026gt; Cloud in the Lacework Console to display the Compliance page. Choose the Group by Policy. Then for Service Category filter choose S3. Click on LW_S3_2 Ensure the S3 bucket ACL does not grant \u0026lsquo;Everyone\u0026rsquo; WRITE permission [create, overwrite, and delete S3 objects]. This is a critical severity recommendation and lists S3 buckets that are vulnerable. The noncompliance s3 buckets are identified. Click on the View context link to view the steps to resolve the noncompliance. Click on LW_S3_16 Ensure the S3 bucket has versioning enabled. Versioning is a recommendation to protect yourself from ransomware attacks. This lists S3 buckets that should have versioning enabled. Lacework provides security recommendations for your cloud environments. These can help you prevent attacks before they happen. Let\u0026rsquo;s see how these generate events to notify you of issues that you should address.\nChallenge If you don\u0026#39;t know how to remediate, how could you learn how? Use the Additional Info link on the recommendation to find the steps to remediate. "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/4_cspm_plus/43_anomaly.html",
	"title": "The Lacework Anomaly Detection",
	"tags": [],
	"description": "",
	"content": "In the previous sections, we looked at prevention - identifying issues that make you vulnerable to an attack. Now we will look at Lacework\u0026rsquo;s anomaly detection events with Polygraph. The Lacework Polygraph analyzes an array of cloud factors to detect breaches. There are currently six Lacework polygraph analysis groups:\nApplication/process communications Application launches Machine communications Machine servers Privilege changes Insider behaviors Click on this CloudTrail Dossier that represents malicious activity from an AWS user badguy. Anomaly events are detected through Lacework\u0026rsquo;s Polygraph machine learning technology. Polygraph tracks the user and API activities and detects anomalous and potentially malicious behavior. Scroll down to the Polygraph to see a visual representation of the API interactions. Scroll down to the Cloudtrail logs. Look at the API Calls to s3:ListBuckets along with a kms:GenerateDataKey shows the user searching S3 buckets and then initiating a large KMS encryption task. Scroll back to the top and click on the View in alerts link. This will take you to the alerts coming from this anomaly detection. Click on any alert to view the details. "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/5_devsecops_plus_eks/51_arch.html",
	"title": "Architecture",
	"tags": [],
	"description": "",
	"content": "The architecture for this section is depicted below.\n"
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/5_devsecops_plus_eks/52_cloudformation.html",
	"title": "Lacework, CodePipeline, CodeBuild, CodeGuru, ECR &amp; EKS in CloudFormation",
	"tags": [],
	"description": "",
	"content": "Lacework, CodePipeline, CodeBuild, ECR \u0026amp; EKS for our CI/CD pipeline is provisioned using CloudFormation. We will review these CloudFormation templates.\nGo to https://github.com/lacework-alliances/aws-immersion-day-code in your browser. Go to the templates directory and view the setup-pipelines.template.yml. This CloudFormation template provisions CodePipeline, CodeBuild \u0026amp; ECR resources. CodeBuild requires buildspec files. Go to the app directory and view the codebuild-scan-push.yaml and codebuild-deploy-eks.yaml files. codebuild-scan-push.yaml has the commands to perform a docker build, Lacework image vulnerability scan and docker push to ECR. codebuild-deploy-eks.yaml deploys the container to the EKS cluster. Go to the templates directory and view the setup-bastion-eks.template.yml. This CloudFormation template our EKS cluster with the Lacework agent for runtime protection. These templates have already been executed in your AWS environment. We can now view these resources in your AWS console.\n"
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/5_devsecops_plus_eks/53_codepipeline.html",
	"title": "CodePipeline: A DevSecOps Pipeline",
	"tags": [],
	"description": "",
	"content": "AWS CodePipeline orchestrates our CI/CD process. It pulls our code from a S3 bucket and then uses AWS CodeBuild to build, scan and push our application container image.\nGo to AWS CodePipeline in your AWS console. Click on the AWSSecuredPipeline pipeline. This pipeline has 11 phases:\nSource: pulls the application source code from Amazon S3. ScanCode performs a Java code analysis and identifies security issues. ScanIaC scans the CloudFormation and Kubernetes manifest to identify security misconfigurations. BuildScanPush builds our Docker image, scans for OS and package security vulnerabilities and then pushes it to our ECR repository. ScanStagingImage scans our staging repository to identify additional OS and package security vulnerabilities. DeployToStaging deploys our application to our EKS staging environment. ScanStagingConfig scans our staging environment for security misconfigurations. ApprovalStage provides a manual approval step before deploying the application to the production environment. PromoteToProductionRepo promotes our application from our staging repository to our production repository. ScanProductionImage scans our production repository to identify additional OS and package security vulnerabilities. DeployToProduction deploys our application to our EKS production environment. Click the Release Change button to execute the build if it has not already executed. For each phase, you can click on the Details link to see the execution logs.\nLet\u0026rsquo;s examine these phases in detail.\n"
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/5_devsecops_plus_eks/54_source_phase.html",
	"title": "Source Phase",
	"tags": [],
	"description": "",
	"content": "The Source phase use a Codepipeline source action to pull our code from a zipped archive in an S3 bucket. This zipped archive contains our source code, K8s manifests and CodeBuild buildspec files. Other source options are also available such as Github and Bitbucket are available through Codestar Connections.\nThe Cloudformation specification of source from a S3 zipped archive for our workshop:\nStages: - Name: Source Actions: - Name: App ActionTypeId: Category: Source Owner: AWS Version: 1 Provider: S3 Configuration: S3Bucket: !Sub \u0026#34;${AWS::AccountId}-app-bucket-${LaceworkAccountName}\u0026#34; S3ObjectKey: !Sub \u0026#34;${S3KeyPrefix}/app/app.zip\u0026#34; PollForSourceChanges: false OutputArtifacts: - Name: App RunOrder: 1 A Github source using AWS Codestar connections:\nStages: - Name: Source Actions: - Name: GitHubRepo ActionTypeId: Category: Source Owner: AWS Provider: CodeStarSourceConnection Version: 1 Configuration: ConnectionArn: arn:aws:codestar-connections:us-west-2:911290716430:connection/baf6fdba-995f-4e59-8497-49c224c3479b FullRepositoryId: lacework-alliances/aws-secured-pipeline BranchName: master OutputArtifacts: - Name: App RunOrder: 1 Codestar connections for other source code repositories can be created from Settings \u0026gt; Connections.\nChallenge Can you simultaneously create a Codestar connection and use it in your AWS CloudFormation? Unfortunately not. The Codestar connection must be created in the AWS console. The process involves authenticating with the source code provider (like GitHub) and setting up the webhook for commit notifications. But you just need to do this once for an organization and not for every repository. "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/5_devsecops_plus_eks/55_scancode_phase.html",
	"title": "ScanCode Phase",
	"tags": [],
	"description": "",
	"content": "In the ScanCode phase, we check our source code for security issues using AWS CodeGuru. AWS CodeGuru can also recommend code quality improvements.\nThe Cloudformation specification of the ScanCode phase is as follows:\n- Name: ScanCode Actions: - Name: ScanCode ActionTypeId: Category: Test Owner: AWS Version: 1 Provider: CodeBuild Configuration: ProjectName: !Ref CodeBuildScanCodeProject InputArtifacts: - Name: App OutputArtifacts: - Name: CodeScanOutput RunOrder: 2 This phase is backed by an AWS CodeBuild project CodeBuildScanCodeProject:\nCodeBuildScanCodeProject: Type: AWS::CodeBuild::Project Properties: Name: ScanCode Description: \u0026#34;Scan Code\u0026#34; Artifacts: Type: CODEPIPELINE Source: Type: CODEPIPELINE BuildSpec: \u0026#34;codebuild-scan-code.yaml\u0026#34; Environment: ComputeType: \u0026#34;BUILD_GENERAL1_SMALL\u0026#34; Image: \u0026#34;aws/codebuild/standard:5.0\u0026#34; Type: \u0026#34;LINUX_CONTAINER\u0026#34; PrivilegedMode: true ServiceRole: !Ref CodeBuildServiceRole This is ultimately backed by the AWS CodeBuild buildspec file codebuild-scan-code.yaml that has the actual commands:\nversion: 0.2 phases: install: runtime-versions: java: corretto11 commands: - java -version - mvn --version - git --version - curl -OL https://github.com/aws/aws-codeguru-cli/releases/download/0.2.1/aws-codeguru-cli.zip - unzip aws-codeguru-cli.zip - export PATH=$PATH:./aws-codeguru-cli/bin build: commands: - aws-codeguru-cli --region us-west-2 --no-prompt --fail-on-recommendations --root-dir ./ --src src --output ./output || true - cat ./output/recommendations.json In this buildspec file, we first install the aws-codeguru-cli and then run the cli against our source code. Notice that we specified \u0026ndash;fail-on-recommendations which would ordinarily fail our pipeline on any issues that are found. For our example though, we let it proceed if issues our found.\nNow let\u0026rsquo;s view the results of this phase by clicking on the Details link in CodePipeline. This will take us to the AWS CodeBuild build logs.\nScroll down the log to find a security issue and Java best practices issue that was discovered in our code.\nChallenge Which languages does CodeGuru support Python and Java. "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/5_devsecops_plus_eks/56_scaniac_phase.html",
	"title": "ScanIaC Phase",
	"tags": [],
	"description": "",
	"content": "In the ScanIaC phase, we check our infrastructure as code (IaC) files for security misconfigurations that could make us vulnerable due to items like mis-configured security groups, IAM policies and more. We use the Lacework CLI to check for IaC misconfigurations. Lacework IaC security can check Terraform, CloudFormation, Helm, Kustomize and Kubernetes manifest files for security issues. Our workshop codebase uses CloudFormation and Kubernetes manifests and these will be scanned.\nThe Cloudformation specification of the ScanIaC phase is as follows:\n- Name: ScanIaC Actions: - Name: ScanIaC ActionTypeId: Category: Test Owner: AWS Version: 1 Provider: CodeBuild Configuration: ProjectName: !Ref CodeBuildScanIaCProject InputArtifacts: - Name: App OutputArtifacts: - Name: IaCScanOutput RunOrder: 3 This phase is backed by an AWS CodeBuild project CodeBuildScanIaCProject:\nCodeBuildScanIaCProject: Type: AWS::CodeBuild::Project Properties: Name: ScanIaC Description: \u0026#34;Scan IaC\u0026#34; Artifacts: Type: CODEPIPELINE Source: Type: CODEPIPELINE BuildSpec: \u0026#34;codebuild-scan-iac.yaml\u0026#34; Environment: ComputeType: \u0026#34;BUILD_GENERAL1_SMALL\u0026#34; Image: \u0026#34;aws/codebuild/standard:5.0\u0026#34; Type: \u0026#34;LINUX_CONTAINER\u0026#34; PrivilegedMode: true ServiceRole: !Ref CodeBuildServiceRole This is backed by the AWS CodeBuild buildspec file codebuild-scan-iac.yaml that has the actual commands:\nversion: 0.2 env: parameter-store: SOLUBLE_ORG_ID: \u0026#34;SOLUBLE_ORG_ID\u0026#34; SOLUBLE_API_TOKEN: \u0026#34;SOLUBLE_API_TOKEN\u0026#34; phases: install: commands: - curl https://raw.githubusercontent.com/soluble-ai/soluble-cli/master/linux-install.sh | bash build: commands: - export SOLUBLE_ORG_ID=$SOLUBLE_ORG_ID - export SOLUBLE_API_TOKEN=$SOLUBLE_API_TOKEN - soluble k8s-scan --upload --fail high || true - soluble cfn-scan --upload --fail high || true In this buildspec file, we install the Lacework CLI (soluble) and then run the cli against our source code. We can use the \u0026ndash;fail which to fail the pipeline.\nNow let\u0026rsquo;s view the results of this phase by clicking on the Details link in CodePipeline. This will take us to the AWS CodeBuild build logs.\nScroll down the log to find security issues in our Kubernetes deployment manifest.\nChallenge Can you customize the IaC security policies? YES! See https://docs.lacework.com/iac/modify-iac-security-policies. "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/5_devsecops_plus_eks/57_buildscanpush_phase.html",
	"title": "BuildScanPush Phase",
	"tags": [],
	"description": "",
	"content": "In the BuildScanPush phase, we build our Docker image, scan it for software package and OS library security vulnerabilities and if it passes, we push it to ECR. The scanning for software and OS vulnerabilities is also performed by the Lacework CLI (inline scanner).\nThe Cloudformation specification of the BuildScanPush phase is as follows:\n- Name: BuildScanPush Actions: - Name: BuildScanPush ActionTypeId: Category: Build Owner: AWS Version: 1 Provider: CodeBuild Configuration: ProjectName: !Ref CodeBuildBuildScanPushProject InputArtifacts: - Name: App OutputArtifacts: - Name: BuildScanPushOutput RunOrder: 4 This phase is backed by an AWS CodeBuild project CodeBuildBuildScanPushProject:\nCodeBuildBuildScanPushProject: Type: AWS::CodeBuild::Project Properties: Name: BuildScanPush Description: \u0026#34;Build, Scan, Push\u0026#34; Artifacts: Type: CODEPIPELINE Source: Type: CODEPIPELINE BuildSpec: \u0026#34;codebuild-build-scan-push.yaml\u0026#34; Environment: ComputeType: \u0026#34;BUILD_GENERAL1_SMALL\u0026#34; Image: \u0026#34;aws/codebuild/standard:5.0\u0026#34; Type: \u0026#34;LINUX_CONTAINER\u0026#34; PrivilegedMode: true EnvironmentVariables: - Name: AWS_REGION Value: !Ref AWS::Region - Name: IMAGE_NAME Value: \u0026#34;staging-demo-app\u0026#34; - Name: DOCKER_REG Value: !Sub \u0026#34;${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com\u0026#34; ServiceRole: !Ref CodeBuildServiceRole This is backed by the AWS CodeBuild buildspec file codebuild-build-scan-push.yaml that has the actual commands:\nversion: 0.2 env: parameter-store: LW_ACCOUNT: \u0026#34;LW_ACCOUNT\u0026#34; LW_ACCESS_TOKEN: \u0026#34;INLINE_SCANNER_TOKEN\u0026#34; phases: install: runtime-versions: java: corretto8 commands: - curl -L https://github.com/lacework/lacework-vulnerability-scanner/releases/latest/download/lw-scanner-linux-amd64 -o lw-scanner - chmod +x lw-scanner build: commands: - mvn clean install - pwd - ls - ls target - docker build -t \u0026#34;$DOCKER_REG/$IMAGE_NAME:$CODEBUILD_BUILD_NUMBER\u0026#34; -t \u0026#34;$DOCKER_REG/$IMAGE_NAME:latest\u0026#34; . post_build: commands: - export LW_ACCOUNT_NAME=$LW_ACCOUNT - export LW_ACCESS_TOKEN=$LW_ACCESS_TOKEN - export LW_SCANNER_DISABLE_UPDATES=true - export LW_SCANNER_SAVE_RESULTS=true - rm -rf ./evaluations/$IMAGE_NAME/$CODEBUILD_BUILD_NUMBER/evaluation_*.json || true - ./lw-scanner image evaluate $DOCKER_REG/$IMAGE_NAME $CODEBUILD_BUILD_NUMBER --build-id $CODEBUILD_BUILD_NUMBER --data-directory . || true - aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $DOCKER_REG - docker image push -a \u0026#34;$DOCKER_REG/$IMAGE_NAME\u0026#34; In this buildspec file, we first build our Docker image. Then we install and run the Lacework CLI (inline scanner) to check for software and OS security issues. Then we push the image to our ECR repository.\nNow let\u0026rsquo;s view the results of this phase by clicking on the Details link in CodePipeline. This will take us to the AWS CodeBuild build logs.\nScroll down the log to find security issues in our Docker image. We see many CVEs identified for the Java software libraries used in our application.\nChallenge Can you customize the software and OS vulnerability security policies? YES! https://docs.lacework.com/onboarding/integrate-inline-scanner#container-vulnerability-policy-support. "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/5_devsecops_plus_eks/58_scanstagingimage_phase.html",
	"title": "ScanStagingImage Phase",
	"tags": [],
	"description": "",
	"content": "In the ScanStagingImage phase, we scan our staging repository for software and OS vulnerabilities. Why do we do this? In our example application, we have just one image. But in a real world application you will likely have dozens of images - some authored by your teams while other are 3rd party and open-source. These all need to be checked. Again, we will use the Lacework CLI (registry scanning) to check for vulnerabilities in the staging repository.\nThe Cloudformation specification of the ScanStagingImage phase is as follows:\n- Name: ScanStagingImage Actions: - Name: ScanStagingImage ActionTypeId: Category: Test Owner: AWS Version: 1 Provider: CodeBuild Configuration: ProjectName: !Ref CodeBuildScanStagingImageProject InputArtifacts: - Name: App OutputArtifacts: - Name: ScanStagingImage RunOrder: 5 This phase is backed by an AWS CodeBuild project CodeBuildScanStagingImageProject:\nCodeBuildScanStagingImageProject: Type: AWS::CodeBuild::Project Properties: Name: ScanStagingImage Description: \u0026#34;Scan Staging Image\u0026#34; Artifacts: Type: CODEPIPELINE Source: Type: CODEPIPELINE BuildSpec: \u0026#34;codebuild-scan-staging-image.yaml\u0026#34; Environment: ComputeType: \u0026#34;BUILD_GENERAL1_SMALL\u0026#34; Image: \u0026#34;aws/codebuild/standard:5.0\u0026#34; Type: \u0026#34;LINUX_CONTAINER\u0026#34; EnvironmentVariables: - Name: IMAGE_NAME Value: \u0026#34;staging-demo-app\u0026#34; - Name: DOCKER_REG Value: !Sub \u0026#34;${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com\u0026#34; ServiceRole: !Ref CodeBuildServiceRole This is backed by the AWS CodeBuild buildspec file codebuild-scan-staging-image.yaml that has the actual commands:\nversion: 0.2 env: parameter-store: LW_ACCOUNT: \u0026#34;LW_ACCOUNT\u0026#34; LW_API_KEY: \u0026#34;LW_API_KEY\u0026#34; LW_API_SECRET: \u0026#34;LW_API_SECRET\u0026#34; phases: install: commands: - curl https://raw.githubusercontent.com/lacework/go-sdk/master/cli/install.sh | bash build: commands: - export LW_ACCOUNT=$LW_ACCOUNT - export LW_API_KEY=$LW_API_KEY - export LW_API_SECRET=$LW_API_SECRET - lacework vulnerability container scan $DOCKER_REG $IMAGE_NAME latest --poll --fail_on_severity critical || true In this buildspec file, we use the Lacework CLI to scan our staging ECR repository.\nNow let\u0026rsquo;s view the results of this phase by clicking on the Details link in CodePipeline. This will take us to the AWS CodeBuild build logs.\nScroll down the log to find security issues in the staging repository. We see many vulnerabilities identified.\nYou can also view these vulnerabilities in the Lacework console.\nChallenge Why is it important to have a staging repository? The staging repository contains all the released applications that are ready to go to production. It becomes the last archive of images to check before they move to production. "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/5_devsecops_plus_eks/59_deploytostaging_phase.html",
	"title": "DeployToStaging Phase",
	"tags": [],
	"description": "",
	"content": "In the DeployToStaging phase, we deploy our application to our staging environment - an Amazon Elastic Kubernetes Service (EKS) cluster. This is done by applying a Kubernetes deployment manifest (the one that was previously scanned as part of IaC security) that pulls our staging image.\nThe Cloudformation specification of the DeployToStaging phase is as follows:\n- Name: DeployToStaging Actions: - Name: DeployToStaging ActionTypeId: Category: Build Owner: AWS Version: 1 Provider: CodeBuild Configuration: ProjectName: !Ref CodeBuildDeployStagingProject InputArtifacts: - Name: App OutputArtifacts: - Name: DeployStagingOutput RunOrder: 6 This phase is backed by an AWS CodeBuild project CodeBuildDeployStagingProject:\nCodeBuildDeployStagingProject: Type: AWS::CodeBuild::Project Properties: Name: DeployToStaging Description: \u0026#34;Deploy to Staging\u0026#34; Artifacts: Type: CODEPIPELINE Source: Type: CODEPIPELINE BuildSpec: \u0026#34;codebuild-deploy-staging.yaml\u0026#34; Environment: ComputeType: \u0026#34;BUILD_GENERAL1_SMALL\u0026#34; Image: \u0026#34;aws/codebuild/standard:5.0\u0026#34; Type: \u0026#34;LINUX_CONTAINER\u0026#34; EnvironmentVariables: - Name: AWS_ACCOUNT_ID Value: !Ref AWS::AccountId - Name: AWS_REGION Value: !Ref AWS::Region - Name: DOCKER_REG Value: !Sub \u0026#34;${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com\u0026#34; - Name: EKS_CLUSTER Value: !Sub \u0026#34;${AWS::AccountId}-eks-${LaceworkAccountName}\u0026#34; - Name: IMAGE_NAME Value: \u0026#34;staging-demo-app\u0026#34; - Name: IMAGE_TAG Value: \u0026#34;latest\u0026#34; ServiceRole: !Ref CodeBuildServiceRole This is backed by the AWS CodeBuild buildspec file codebuild-deploy-staging.yaml that has the actual commands:\nversion: 0.2 phases: post_build: commands: - aws eks update-kubeconfig --region $AWS_REGION --name $EKS_CLUSTER --role-arn arn:aws:iam::$AWS_ACCOUNT_ID:role/eks-codebuild-kubectl-role - sed \u0026#34;s|imageName|$DOCKER_REG/$IMAGE_NAME:$IMAGE_TAG|g\u0026#34; deployment.yaml \u0026gt; staging-deployment.yaml - cat staging-deployment.yaml - kubectl apply -f staging-deployment.yaml -n staging-demo-app - while [ -z \u0026#34;$url\u0026#34; ]; do url=$(kubectl describe service demo-app -n staging-demo-app | grep \u0026#39;LoadBalancer Ingress:\u0026#39; | awk \u0026#39;{printf \u0026#34;http://%s\u0026#34;,$3;}\u0026#39;); sleep 2; done - echo \u0026#34;$url\u0026#34; - echo \u0026#34;Staging Demo App launched!\u0026#34; In this buildspec file, we authenticate with the EKS cluster, make a minor edit to the Kubernetes deployment manifest for the new image and then apply the manifest to deploy the application.\nNow let\u0026rsquo;s view the results of this phase by clicking on the Details link in CodePipeline. This will take us to the AWS CodeBuild build logs.\nScroll down the log to the deployment output.\n"
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/099_survey.html",
	"title": "Survey",
	"tags": [],
	"description": "",
	"content": "Survey To help us improve this product, please take some time to fill out the Survey "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/5_devsecops_plus_eks/510_scanstagingconfig_phase.html",
	"title": "ScanStagingConfig Phase",
	"tags": [],
	"description": "",
	"content": "In the ScanStagingConfig phase, we scan our staging environment and check all the active resource configurations to ensure that we don\u0026rsquo;t have misconfigurations that could make us vulnerable. To do this, we use the [Lacework CLI (compliance)] (https://docs.lacework.com/cli/compliance-reports#compliance-for-aws) to run an assessment and determine if we have any issues.\nThe Cloudformation specification of the ScanStagingConfig phase is as follows:\n- Name: ScanStagingConfig Actions: - Name: ScanStagingConfig ActionTypeId: Category: Test Owner: AWS Version: 1 Provider: CodeBuild Configuration: ProjectName: !Ref CodeBuildScanStagingConfigProject InputArtifacts: - Name: App RunOrder: 7 This phase is backed by an AWS CodeBuild project CodeBuildScanStagingConfigProject:\nCodeBuildScanStagingConfigProject: Type: AWS::CodeBuild::Project Properties: Name: ScanStagingConfig Description: \u0026#34;Scan Staging Config\u0026#34; Artifacts: Type: CODEPIPELINE Source: Type: CODEPIPELINE BuildSpec: \u0026#34;codebuild-scan-staging-config.yaml\u0026#34; Environment: ComputeType: \u0026#34;BUILD_GENERAL1_SMALL\u0026#34; Image: \u0026#34;aws/codebuild/standard:5.0\u0026#34; Type: \u0026#34;LINUX_CONTAINER\u0026#34; EnvironmentVariables: - Name: AWS_ACCOUNT_ID Value: !Ref AWS::AccountId ServiceRole: !Ref CodeBuildServiceRole This is backed by the AWS CodeBuild buildspec file codebuild-scan-staging-config.yaml that has the actual commands:\nversion: 0.2 env: parameter-store: LW_ACCOUNT: \u0026#34;LW_ACCOUNT\u0026#34; LW_API_KEY: \u0026#34;LW_API_KEY\u0026#34; LW_API_SECRET: \u0026#34;LW_API_SECRET\u0026#34; phases: install: commands: - curl https://raw.githubusercontent.com/lacework/go-sdk/master/cli/install.sh | bash build: commands: - export LW_ACCOUNT=$LW_ACCOUNT - export LW_API_KEY=$LW_API_KEY - export LW_API_SECRET=$LW_API_SECRET - lacework compliance aws run-assessment $AWS_ACCOUNT_ID --noninteractive || true - lacework compliance aws get-report $AWS_ACCOUNT_ID --json --noninteractive \u0026gt; aws-assessment.json - cat aws-assessment.json - cat aws-assessment.json | jq \u0026#39;.summary[0].num_severity_1_non_compliance\u0026#39; In this buildspec file, we use the Lacework CLI first run an AWS compliance assessment, we get the report and then parse the report for any non-compliance.\nNow let\u0026rsquo;s view the results of this phase by clicking on the Details link in CodePipeline. This will take us to the AWS CodeBuild build logs.\nScroll down to the end of the log to see the compliance results.\nYou can also view the compliance results in the Lacework console.\nChallenge Why is it important to have a staging environment? The staging environment is important because it contains the applications and configurations that you intend to deploy to production. This is your last opportunity to check for vulnerabilities and security misconfigurations before you deploy to production. "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/5_devsecops_plus_eks/511_approvalstage_phase.html",
	"title": "Approval Phase",
	"tags": [],
	"description": "",
	"content": "In the ApprovalStage phase, we included a manual approval step before releasing the application to production. Some organizations may have an automated method of approving production deployments, use canary deployments or other methods.\n"
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/5_devsecops_plus_eks/512_promotetoprodrepo_phase.html",
	"title": "PromoteToProdRepo Phase",
	"tags": [],
	"description": "",
	"content": "In the PromoteToProdRepo phase, we promote our image from a staging to production. Some applications will have multiple images that must be promoted. Depending on the type of Docker registry, promotion may involve special tagging or copying images between repositories. For ECR, we push the image to a production repository.\nThe Cloudformation specification of the ScanStagingConfig phase is as follows:\n- Name: PromoteToProductionRepo Actions: - Name: PromoteToProductionRepo ActionTypeId: Category: Build Owner: AWS Version: 1 Provider: CodeBuild Configuration: ProjectName: !Ref CodeBuildPromoteProductionRepoProject InputArtifacts: - Name: App OutputArtifacts: - Name: PromoteProductionRepoOutput RunOrder: 9 This phase is backed by an AWS CodeBuild project CodeBuildPromoteProductionRepoProject:\nCodeBuildPromoteProductionRepoProject: Type: AWS::CodeBuild::Project Properties: Name: PromoteProductionRepo Description: \u0026#34;Promote Production Repo\u0026#34; Artifacts: Type: CODEPIPELINE Source: Type: CODEPIPELINE BuildSpec: \u0026#34;codebuild-promote-production-repo.yaml\u0026#34; Environment: ComputeType: \u0026#34;BUILD_GENERAL1_SMALL\u0026#34; Image: \u0026#34;aws/codebuild/standard:5.0\u0026#34; Type: \u0026#34;LINUX_CONTAINER\u0026#34; PrivilegedMode: true EnvironmentVariables: - Name: AWS_REGION Value: !Ref AWS::Region - Name: STAGING_IMAGE_NAME Value: \u0026#34;staging-demo-app\u0026#34; - Name: PROD_IMAGE_NAME Value: \u0026#34;prod-demo-app\u0026#34; - Name: IMAGE_TAG Value: \u0026#34;latest\u0026#34; - Name: DOCKER_REG Value: !Sub \u0026#34;${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com\u0026#34; ServiceRole: !Ref CodeBuildServiceRole This is backed by the AWS CodeBuild buildspec file codebuild-promote-production-repo.yaml that has the actual commands:\nversion: 0.2 phases: build: commands: - aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $DOCKER_REG - docker pull \u0026#34;$DOCKER_REG/$STAGING_IMAGE_NAME\u0026#34; - docker tag \u0026#34;$DOCKER_REG/$STAGING_IMAGE_NAME:latest\u0026#34; \u0026#34;$DOCKER_REG/$PROD_IMAGE_NAME:latest\u0026#34; - docker image push -a \u0026#34;$DOCKER_REG/$PROD_IMAGE_NAME\u0026#34; In this buildspec file, we execute Docker commands to pull and push to our production repository.\nYou can view the results of this phase by clicking on the Details link in CodePipeline.\n"
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/5_devsecops_plus_eks/513_scanprodimage_phase.html",
	"title": "ScanProdImage Phase",
	"tags": [],
	"description": "",
	"content": "In the ScanProdImage phase, we scan our production repository for software and OS vulnerabilities like we did with the staging repository. Why do we do this? It\u0026rsquo;s important to scan your production repositories. In rare cases, application images may mistakenly bypass the software delivery pipeline process and end up in production. This scan is extra assurance that everything is checked. Again, we will use the Lacework CLI (registry scanning) to check for vulnerabilities in the repository.\nThe Cloudformation specification of the ScanProdImage phase is as follows:\n- Name: ScanProductionImage Actions: - Name: ScanProductionImage ActionTypeId: Category: Test Owner: AWS Version: 1 Provider: CodeBuild Configuration: ProjectName: !Ref CodeBuildScanProductionImageProject InputArtifacts: - Name: App OutputArtifacts: - Name: ScanProductionImageOutput RunOrder: 10 This phase is backed by an AWS CodeBuild project CodeBuildScanProductionImageProject:\nCodeBuildScanProductionImageProject: Type: AWS::CodeBuild::Project Properties: Name: ScanProductionImage Description: \u0026#34;Scan Production Image\u0026#34; Artifacts: Type: CODEPIPELINE Source: Type: CODEPIPELINE BuildSpec: \u0026#34;codebuild-scan-production-image.yaml\u0026#34; Environment: ComputeType: \u0026#34;BUILD_GENERAL1_SMALL\u0026#34; Image: \u0026#34;aws/codebuild/standard:5.0\u0026#34; Type: \u0026#34;LINUX_CONTAINER\u0026#34; EnvironmentVariables: - Name: DOCKER_REG Value: !Sub \u0026#34;${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com\u0026#34; - Name: IMAGE_NAME Value: \u0026#34;prod-demo-app\u0026#34; - Name: IMAGE_TAG Value: \u0026#34;latest\u0026#34; ServiceRole: !Ref CodeBuildServiceRole This is backed by the AWS CodeBuild buildspec file codebuild-scan-production-image.yaml that has the actual commands:\nversion: 0.2 env: parameter-store: LW_ACCOUNT: \u0026#34;LW_ACCOUNT\u0026#34; LW_API_KEY: \u0026#34;LW_API_KEY\u0026#34; LW_API_SECRET: \u0026#34;LW_API_SECRET\u0026#34; phases: install: commands: - curl https://raw.githubusercontent.com/lacework/go-sdk/master/cli/install.sh | bash build: commands: - export LW_ACCOUNT=$LW_ACCOUNT - export LW_API_KEY=$LW_API_KEY - export LW_API_SECRET=$LW_API_SECRET - lacework vulnerability container scan $DOCKER_REG $IMAGE_NAME latest --poll --fail_on_severity critical || true In this buildspec file, we use the Lacework CLI to scan our production ECR repository.\nYou can view the results of this phase by clicking on the Details link in CodePipeline.\n"
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/5_devsecops_plus_eks/514_deploytoprod_phase.html",
	"title": "DeployToProduction Phase",
	"tags": [],
	"description": "",
	"content": "In the final phase, DeployToProduction, we deploy our application to our production environment. This is done by applying a Kubernetes deployment manifest (the one that was previously scanned as part of IaC security) that pulls our production image.\nThe Cloudformation specification of the DeployToProduction phase is as follows:\n- Name: DeployToProduction Actions: - Name: DeployToProduction ActionTypeId: Category: Build Owner: AWS Version: 1 Provider: CodeBuild Configuration: ProjectName: !Ref CodeBuildDeployProductionProject InputArtifacts: - Name: App OutputArtifacts: - Name: DeployProductionOutput RunOrder: 11 This phase is backed by an AWS CodeBuild project CodeBuildDeployProductionProject:\nCodeBuildDeployProductionProject: Type: AWS::CodeBuild::Project Properties: Name: DeployToProduction Description: \u0026#34;Deploy to Production\u0026#34; Artifacts: Type: CODEPIPELINE Source: Type: CODEPIPELINE BuildSpec: \u0026#34;codebuild-deploy-prod.yaml\u0026#34; Environment: ComputeType: \u0026#34;BUILD_GENERAL1_SMALL\u0026#34; Image: \u0026#34;aws/codebuild/standard:5.0\u0026#34; Type: \u0026#34;LINUX_CONTAINER\u0026#34; EnvironmentVariables: - Name: AWS_ACCOUNT_ID Value: !Ref AWS::AccountId - Name: AWS_REGION Value: !Ref AWS::Region - Name: DOCKER_REG Value: !Sub \u0026#34;${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com\u0026#34; - Name: EKS_CLUSTER Value: !Sub \u0026#34;${AWS::AccountId}-eks-${LaceworkAccountName}\u0026#34; - Name: IMAGE_NAME Value: \u0026#34;prod-demo-app\u0026#34; - Name: IMAGE_TAG Value: \u0026#34;latest\u0026#34; ServiceRole: !Ref CodeBuildServiceRole This is backed by the AWS CodeBuild buildspec file codebuild-deploy-prod.yaml that has the actual commands:\nversion: 0.2 phases: post_build: commands: - aws eks update-kubeconfig --region $AWS_REGION --name $EKS_CLUSTER --role-arn arn:aws:iam::$AWS_ACCOUNT_ID:role/eks-codebuild-kubectl-role - sed \u0026#34;s|imageName|$DOCKER_REG/$IMAGE_NAME:$IMAGE_TAG|g\u0026#34; deployment.yaml \u0026gt; prod-deployment.yaml - cat prod-deployment.yaml - kubectl apply -f prod-deployment.yaml -n prod-demo-app - while [ -z \u0026#34;$url\u0026#34; ]; do url=$(kubectl describe service demo-app -n prod-demo-app | grep \u0026#39;LoadBalancer Ingress:\u0026#39; | awk \u0026#39;{printf \u0026#34;http://%s\u0026#34;,$3;}\u0026#39;); sleep 2; done - echo \u0026#34;$url\u0026#34; - echo \u0026#34;Prod Demo App launched!\u0026#34; In this buildspec file, we authenticate with the EKS cluster, make a minor edit to the Kubernetes deployment manifest for the new image and then apply the manifest to deploy the application.\nYou can view the results of this phase by clicking on the Details link in CodePipeline. This will take us to the AWS CodeBuild build logs.\n"
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/cleanup.html",
	"title": "Cleanup",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/resources.html",
	"title": "Resources",
	"tags": [],
	"description": "",
	"content": " Lacework Platform Documentation - The full Lacework Platform documentation. "
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/schedule.html",
	"title": "Schedule",
	"tags": [],
	"description": "",
	"content": " Intro Lacework/Session Overview (Slides) - 15 mins Security Essentials and Best Practices (Slides) - 15 mins Environment Setup (Hands-on) - 10 mins Platform Overview (Hands-on/Demo) - 20 mins Advanced Cloud Security Posture Management CSPM+ (Hands-on/Demo) 15 mins DevSecOps+ Secured Software Delivery Pipeline (Hands-on/Demo) - 20 mins Total time: 1 hr 45 mins\n"
},
{
	"uri": "https://lacework-alliances.github.io/aws-immersion-day/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]